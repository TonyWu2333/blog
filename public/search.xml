<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>利用mklink指令清理c盘</title>
      <link href="/2024/03/05/%E5%88%A9%E7%94%A8mklink%E6%8C%87%E4%BB%A4%E6%B8%85%E7%90%86c%E7%9B%98/"/>
      <url>/2024/03/05/%E5%88%A9%E7%94%A8mklink%E6%8C%87%E4%BB%A4%E6%B8%85%E7%90%86c%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="利用mklink指令清理c盘"><a href="#利用mklink指令清理c盘" class="headerlink" title="利用mklink指令清理c盘"></a>利用mklink指令清理c盘</h1><p>今天发现c盘满了，想清理一下，但是面对c盘中的文件又不敢轻举妄动。在不清楚文件作用的情况下，直接删除文件还是有风险的。那么有没有什么方法可以保留文件但是同时又把c盘中的空间清理出来呢？带着这个问题，我打开搜索引擎，果然发现了符合我需求的办法。</p><h2 id="mklink"><a href="#mklink" class="headerlink" title="mklink"></a>mklink</h2><p>没错，解决方案就是windows系统自带的指令——mklink，当我们在cmd输入<code>mklink /?</code>时，控制台会返回以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MKLINK [[/D] | [/H] | [/J]] Link Target</span><br><span class="line"></span><br><span class="line">        /D      创建目录符号链接。默认为文件</span><br><span class="line">                符号链接。</span><br><span class="line">        /H      创建硬链接而非符号链接。</span><br><span class="line">        /J      创建目录联接。</span><br><span class="line">        Link    指定新的符号链接名称。</span><br><span class="line">        Target  指定新链接引用的路径</span><br><span class="line">                (相对或绝对)。</span><br></pre></td></tr></table></figure><h2 id="windows链接类型"><a href="#windows链接类型" class="headerlink" title="windows链接类型"></a>windows链接类型</h2><p>为了看懂控制台给出的用法，我查询了windows的各个链接类型以及他们的区别</p><ol><li><p>快捷方式（Shortcut）：这个是最常见的链接类型了，我就不过多介绍</p></li><li><p>符号链接（Symbolic Link）：符号链接的路径可以是相对路径或绝对路径，可以是目录或文件，不占空间，可以跨本地磁盘，也可以跨网络磁盘（共享目录）。源目录移动、重命名或删除后，链接目录无效；链接目录删除，源目录不受影响；源目录里面的文件发生变化时（新增、修改、删除），链接目录里面的文件同步发生变化，反之，同样成立。</p></li><li><p>联接（Junction）：联接的路径只能是绝对路径，只能是目录，不占空间，只能跨本地磁盘。其他与符号链接差别不大。</p></li><li><p>硬链接（Hard Link）：硬链接的路径只能是绝对路径，占用空间和源文件一样且只能是文件。源文件删除后，链接文件无效；链接文件删除，源文件不受影响；只有将源文件和链接文件全部删除时，才会将文件真正的删除；当源文件内容发生变化时（修改），链接文件同步发生修改，反之，同样成立。</p></li></ol><h2 id="文件符号链接操作"><a href="#文件符号链接操作" class="headerlink" title="文件符号链接操作"></a>文件符号链接操作</h2><p>作为测试，我首先在E盘和F盘各创建一个test文件夹。并创建了<code>E:\test\text1.txt</code>和<code>F:\test\text2.txt</code>两个文件。然后运行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink E:\test\text1.txt F:\test\text2.txt</span><br></pre></td></tr></table></figure><p>但是控制台给我一个报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当文件已存在时，无法创建该文件。</span><br></pre></td></tr></table></figure><p>于是我删除了<code>E:\test\text1.txt</code>，然后再次运行指令，控制台返回了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为 E:\test\text1.txt &lt;&lt;===&gt;&gt; F:\test\text2.txt 创建的符号链接</span><br></pre></td></tr></table></figure><p>此时<code>E:\test</code>下多出了一个叫<code>test1.txt</code>的文件，并且有一个类似超链接的标志，我在任意一个txt文件中修改内容，另一个则会同步改变。</p><h2 id="目录符号链接操作"><a href="#目录符号链接操作" class="headerlink" title="目录符号链接操作"></a>目录符号链接操作</h2><p>与文件符号链接一样，我们现在<code>F:\test</code>下创建了一个<code>target</code>的文件夹，然后运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mklink /d E:\test\link F:\test\target</span><br><span class="line">为 E:\test\link &lt;&lt;===&gt;&gt; F:\test\target 创建的符号链接</span><br></pre></td></tr></table></figure><p>现在<code>E:\test</code>又出现一个<code>link</code>文件夹，这个文件夹与target也是同步变化的，最重要的是，这个link文件夹是不占空间的，也就是说，我们可以利用这种方法将c盘的一些文件夹作为link符号链接到target上，以达到清理c盘空间的目的。</p><h2 id="目录联接操作"><a href="#目录联接操作" class="headerlink" title="目录联接操作"></a>目录联接操作</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mklink /j E:\test\link F:\test\target</span><br><span class="line">为 E:\test\link &lt;&lt;===&gt;&gt; F:\test\target 创建的联接</span><br></pre></td></tr></table></figure><p>在这个例子中与目录符号链接的效果差别不大</p><h2 id="硬链接操作"><a href="#硬链接操作" class="headerlink" title="硬链接操作"></a>硬链接操作</h2><p>我们将<code>E:\test\</code>清空并创建<code>F:\test\text2.txt</code>，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /h E:\test\text1.txt F:\test\text2.txt</span><br></pre></td></tr></table></figure><p>系统报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">系统无法将文件移到不同的磁盘驱动器。</span><br></pre></td></tr></table></figure><p>差点忘了硬链接不能跨本地磁盘</p><p>重新执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mklink /h F:\test\text3.txt F:\test\text2.txt</span><br></pre></td></tr></table></figure><p>运行成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为 F:\test\text3.txt &lt;&lt;===&gt;&gt; F:\test\text2.txt 创建了硬链接</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天通过清理c盘的契机了解到mklink指令，并深入了解（虽然也不是很深入）了windows系统上不同的链接类型。如果大家有什么想补充或者纠错的，请在评论区留言~</p>]]></content>
      
      
      <categories>
          
          <category> CMD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmd </tag>
            
            <tag> windows </tag>
            
            <tag> mklink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CREATE行为漏斗模型</title>
      <link href="/2024/03/04/CREATE%E8%A1%8C%E4%B8%BA%E6%BC%8F%E6%96%97%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/03/04/CREATE%E8%A1%8C%E4%B8%BA%E6%BC%8F%E6%96%97%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="CREATE行为漏斗模型"><a href="#CREATE行为漏斗模型" class="headerlink" title="CREATE行为漏斗模型"></a>CREATE行为漏斗模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们构建UI和UX时，我们常常会分析用户的行为，但总是无从下手。CREATE漏斗模型（由Stephen Wendell设计）给我们提供了一个思路。CREATE分别是Cue（线索）、Reaction（反应）、Evaluation（评估）、Ability（能力）、Timing（时机）、Execute（行动）</p><p><img src="https://s2.loli.net/2024/03/04/UKq1cBVWb9YPHXG.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/04/UKq1cBVWb9YPHXG.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="CREATE行为漏斗"></p><h2 id="Cue"><a href="#Cue" class="headerlink" title="Cue"></a>Cue</h2><p>线索提示，即让用户意识到某个产品或功能的存在。吸引用户的注意力并在他的脑袋中留下印象是首要条件。</p><h2 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h2><p>当用户在某一时刻回想起某个产品时，他会有一个感受，可能是有趣的、优雅的，也可能是枯燥的、杂乱的。而这个感受也会对用户之后的行为造成影响。</p><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>在用户产生了使用产品的想法后，他便会开始评估利弊，使用这个软件或功能是否会给他带来价值。如果使用的时间成本或金钱成本过高，大于他使用的预期，那么用户可能会放弃使用。</p><h2 id="Ability"><a href="#Ability" class="headerlink" title="Ability"></a>Ability</h2><p>也许在上一阶段，用户觉得使用这个软件是值的，那么现在还要看他是否具有发起行动的条件，比如此时用户的网络环境较差，无法打开网页，或不知道如何进入某功能页面，这些都会导致用户行动失败。</p><h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>最后是让用户的使用具有紧迫感，如果用户满足了上述条件，但一点都不急，那他有可能想着明天再用吧，然后就忘记了。很多软件推出一些限时活动，也是为了让用户觉得这个行动不能拖延。</p><h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>在前面5层漏斗的筛选下，用户此时终于决定行动起来。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过CREATE行为漏斗模型，我们能够更好地理解用户在与产品或功能互动时的心理过程。从最初的线索提示到最终的行动执行，每个阶段都是用户决策和行为的关键点。利用CREATE行为漏斗模型可以帮助我们更有效地吸引用户、提升产品价值，并促使他们采取行动。</p>]]></content>
      
      
      <categories>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统答疑（一）</title>
      <link href="/2024/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AD%94%E7%96%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/03/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AD%94%E7%96%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="What-are-the-three-main-purposes-of-an-operating-system"><a href="#What-are-the-three-main-purposes-of-an-operating-system" class="headerlink" title="What are the three main purposes of an operating system?"></a><strong>What are the three main purposes of an operating system?</strong></h3><ol><li><p>The three main purposes are to provide a convenient environment for computer users to execute programs on computer hardware.</p></li><li><p>Allocate individual resources of the computer as needed to perform the required tasks. The distribution process should be as fair and reasonable as possible.</p></li><li><p>As a control program, it has two main functions: (1) to supervise the execution of user programs and prevent errors and improper use of the computer; and (2) to manage the operation and control of I&#x2F;O devices.</p></li></ol><h3 id="What-is-the-main-difficulty-that-a-programmer-must-overcome-in-writing-an-operating-system-for-a-real-time-environment"><a href="#What-is-the-main-difficulty-that-a-programmer-must-overcome-in-writing-an-operating-system-for-a-real-time-environment" class="headerlink" title="What is the main difficulty that a programmer must overcome in writing an operating system for a real-time environment?"></a><strong>What is the main difficulty that a programmer must overcome in writing an operating system for a real-time environment?</strong></h3><p>A: The main disadvantage is keeping the operating system within the time constraints of a real-time system. If the system does not complete a task within a certain period of time, it may cause the whole system to crash. Therefore, when writing an operating system for a real-time system, the author must ensure that his scheduling scheme does not allow the response time to exceed the time limit.</p><h3 id="Keeping-in-mind-the-various-definitions-of-operating-system-consider-whether-the-operating-system-should-include-applications-such-as-web-browsers-and-mail-programs-Argue-both-that-it-should-and-that-it-should-not-and-support-your-answers"><a href="#Keeping-in-mind-the-various-definitions-of-operating-system-consider-whether-the-operating-system-should-include-applications-such-as-web-browsers-and-mail-programs-Argue-both-that-it-should-and-that-it-should-not-and-support-your-answers" class="headerlink" title="Keeping in mind the various definitions of operating system, consider whether the operating system should include applications such as web browsers and mail programs. Argue both that it should and that it should not, and support your answers."></a><strong>Keeping in mind the various definitions of operating system, consider whether the operating system should include applications such as web browsers and mail programs. Argue both that it should and that it should not, and support your answers.</strong></h3><p>A: An argument in favor of including popular applications in the operating system is that if the application is embedded in the operating system, it may better take advantage of kernel features and therefore have a performance advantage over applications that run outside the kernel. However, the arguments against embedding applications in the operating system are usually dominant: </p><p>(1) applications are applications — not part of the operating system.</p><p>(2) any performance flaws running in the kernel are offset by security vulnerabilities.</p><p>(3) including applications results in a bloated operating system.</p><h3 id="How-does-the-distinction-between-kernel-mode-and-user-mode-function-as-a-rudimentary-form-of-protection-security-system"><a href="#How-does-the-distinction-between-kernel-mode-and-user-mode-function-as-a-rudimentary-form-of-protection-security-system" class="headerlink" title="How does the distinction between kernel mode and user mode function as a rudimentary form of protection (security) system?"></a><strong>How does the distinction between kernel mode and user mode function as a rudimentary form of protection (security) system?</strong></h3><p>A: The distinction between kernel mode and user mode provides a basic form of protection in the following way. Some instructions can only be executed when the CPU is in kernel mode. Similarly, a hardware device can only be accessed when the program is in kernel mode, and interrupts can only be enabled or disabled when the CPU is in kernel mode. As a result, the CPU has very limited capabilities when executing in user mode, tightening the protection of critical resources.</p><h3 id="Give-two-reasons-why-caches-are-useful-What-problems-do-they-solve-What-problems-do-they-cause-If-a-cache-can-be-made-as-large-as-the-device-for-which-it-is-caching-for-instance-a-cache-as-large-as-a-disk-why-not-make-it-that-large-and-eliminate-the-device"><a href="#Give-two-reasons-why-caches-are-useful-What-problems-do-they-solve-What-problems-do-they-cause-If-a-cache-can-be-made-as-large-as-the-device-for-which-it-is-caching-for-instance-a-cache-as-large-as-a-disk-why-not-make-it-that-large-and-eliminate-the-device" class="headerlink" title="Give two reasons why caches are useful. What problems do they solve?What problems do they cause? If a cache can be made as large as the device for which it is caching (for instance, a cache as large as a disk),why not make it that large and eliminate the device?"></a><strong>Give two reasons why caches are useful. What problems do they solve?What problems do they cause? If a cache can be made as large as the device for which it is caching (for instance, a cache as large as a disk),why not make it that large and eliminate the device?</strong></h3><p>A: Caching is useful when two or more components need to exchange data and the components perform transfers at different speeds. Caching solves the transfer problem by providing an intermediate speed buffer between components. If the fast device data value changes, the data is also in the cache and the cache must be updated. This is especially a problem on multiprocessor systems, where multiple processes may be accessing data. Component can eliminate a cache of equal size, but only if: </p><p>(a) the cache and the component have equal state preservationCapability (that is, if a component retains data when power is removed, the cache must retain the data)</p><p>(b) the cache is affordable because faster storage tends to be more expensive.</p><h3 id="Distinguish-between-the-client–server-and-peer-to-peer-models-of-distributed-systems"><a href="#Distinguish-between-the-client–server-and-peer-to-peer-models-of-distributed-systems" class="headerlink" title="Distinguish between the client–server and peer-to-peer models of distributed systems."></a><strong>Distinguish between the client–server and peer-to-peer models of distributed systems.</strong></h3><p>A: The client-server model strictly separates the roles of the client and the server. Under this model, a client requests a service provided by a server. The peer-to-peer model does not have such a strict role. In fact, all nodes in the system are considered peers, and thus can act as either clients or servers, or both. A node may request a service from another peer, or the node may actually provide such a service to other peers in the system. For example, let’s consider a shared cooking dish.The nodal system of the spectrum. Under the client-server model, all recipes are stored in the server. If the client wants to access the recipe, it must request the recipe from the specified server. With the peer-to-peer model, peer nodes can ask other peer nodes for a specified recipe. A node (or possibly a node) with the requested recipe may provide it to the requesting node. Note that each peer can be both a client (it can request recipes) and a server (it can provide recipes).</p><h3 id="In-a-multiprogramming-and-time-sharing-environment-several-users-share-the-system-simultaneously-This-situation-can-result-in-various-security-problems-a-What-are-two-such-problems-b-Can-we-ensure-the-same-degree-of-security-in-a-time-shared-machine-as-in-a-dedicated-machine-Explain-your-answer"><a href="#In-a-multiprogramming-and-time-sharing-environment-several-users-share-the-system-simultaneously-This-situation-can-result-in-various-security-problems-a-What-are-two-such-problems-b-Can-we-ensure-the-same-degree-of-security-in-a-time-shared-machine-as-in-a-dedicated-machine-Explain-your-answer" class="headerlink" title="In a multiprogramming and time-sharing environment, several users share the system simultaneously. This situation can result in various security problems. a. What are two such problems? b. Can we ensure the same degree of security in a time-shared machine as in a dedicated machine? Explain your answer."></a><strong>In a multiprogramming and time-sharing environment, several users share the system simultaneously. This situation can result in various security problems. a. What are two such problems? b. Can we ensure the same degree of security in a time-shared machine as in a dedicated machine? Explain your answer.</strong></h3><p>A:Two potential issues in multiprogramming and time-sharing environments include:</p><p>1.Data Leakage: Simultaneous access to the system by multiple users may increase the risk of data leakage. Without proper isolation measures, one user may access another user’s data, leading to information disclosure.</p><p>2.Denial of Service (DoS) Attacks: In a multi-user shared system, some users may execute malicious operations to exhaust system resources, thereby impacting the services of other users. In such cases, the system may suffer from denial of service (DoS) attacks.</p><p>Ensuring the same level of security as dedicated machines in time-sharing environments is challenging. Time-sharing systems need to serve multiple users simultaneously, allowing concurrent access to system resources. This shared resource characteristic increases the risk of attacks on the system. In contrast, dedicated machines typically grant access to only one user or a trusted group of users, enabling stricter security measures for enhanced security. While security measures such as access control, encryption, and auditing can be implemented to strengthen the security of time-sharing systems, the shared resource nature makes it impossible to guarantee the same level of security as dedicated machines.</p><h3 id="Describe-some-distributed-applications-that-would-be-appropriate-for-a-peer-to-peer-system"><a href="#Describe-some-distributed-applications-that-would-be-appropriate-for-a-peer-to-peer-system" class="headerlink" title="Describe some distributed applications that would be appropriate for a peer-to-peer system"></a><strong>Describe some distributed applications that would be appropriate for a peer-to-peer system</strong></h3><p>   A:Some distributed applications suitable for peer-to-peer systems include:</p><ol><li>File sharing applications: Allow users to share and exchange files on a peer-to-peer network, such as BitTorrent.</li><li>Blockchain applications: Utilize peer-to-peer networks to distribute and verify transaction data, such as Bitcoin and Ethereum.</li><li>Real-time communication applications: Enable users to communicate directly in real-time on a peer-to-peer network, such as Skype and WhatsApp.</li><li>Distributed computing applications: Utilize multiple nodes in a peer-to-peer network to collectively process computing tasks.</li><li>Decentralized social networks: Allow users to create profiles, share content, and engage in social interactions on a peer-to-peer network, such as Diaspora and Mastodon.</li><li>Content Delivery Networks (CDNs): Utilize peer-to-peer networks to distribute network content to improve access speed and stability, such as BitTorrent CDN.</li></ol><h3 id="Identify-several-advantages-and-several-disadvantages-of-open-source-operating-systems-Include-the-types-of-people-who-would-find-each-aspect-to-be-an-advantage-or-a-disadvantage"><a href="#Identify-several-advantages-and-several-disadvantages-of-open-source-operating-systems-Include-the-types-of-people-who-would-find-each-aspect-to-be-an-advantage-or-a-disadvantage" class="headerlink" title="Identify several advantages and several disadvantages of open-source operating systems. Include the types of people who would find each aspect to be an advantage or a disadvantage."></a><strong>Identify several advantages and several disadvantages of open-source operating systems. Include the types of people who would find each aspect to be an advantage or a disadvantage.</strong></h3><ul><li><p>A:Advantages of open-source operating systems:</p><p>1.Transparency and security: Open-source operating systems allow users to inspect the source code, enhancing transparency and security. Developers and security-conscious users find this advantageous as they can quickly identify and fix vulnerabilities. </p><p>2.Customizability: Open-source operating systems provide extensive customization options. This flexibility attracts power users, developers, and organizations needing tailored solutions to meet specific requirements. </p><p>3.Community support: Open-source projects typically have vibrant communities of developers and users who provide ongoing support, assistance, and knowledge sharing. This collaborative environment is beneficial for individuals seeking help, troubleshooting, or new features. </p><p>4.Cost-effectiveness: Open-source operating systems are often available for free, eliminating licensing costs. This cost-effectiveness is particularly advantageous for budget-conscious individuals, small businesses, educational institutions, and organizations operating in developing countries. </p><p>5.Innovation and rapid development: The openness of the development process fosters innovation and rapid iteration. Developers can freely experiment, iterate, and integrate new features, enabling continuous improvement and staying ahead.</p></li><li><p>Disadvantages of open-source operating systems:</p><p>1.Complexity and learning curve: Open-source operating systems can be highly complex, with a steep learning curve for beginners. Individuals accustomed to more user-friendly interfaces may find configuration and management challenging.</p><p>2.Limited compatibility with proprietary software: Some proprietary software may be incompatible with open-source operating systems, potentially leading to compatibility issues. Users relying on specific proprietary applications or hardware may encounter difficulties or need to seek alternative solutions.</p><p>3.Fragmentation and lack of standardization: The diverse ecosystem of open-source operating systems can lead to fragmentation and lack of standardization. This may result in compatibility issues between different distributions or versions, posing challenges for users seeking environment consistency. </p><p>4.Limited vendor support: Unlike proprietary operating systems, open-source alternatives may lack dedicated vendor support. While community support may be strong, it may not be sufficient for enterprise-level requirements or urgent issues, requiring additional support and maintenance resources. </p><p>5.Security risks: While the transparency of open-source software enhances security in many cases, it may also expose vulnerabilities to malicious users. Without proper management and timely updates, open-source operating systems may become targets for attacks, posing risks to users and organizations.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在vercel上部署hexo框架的博客</title>
      <link href="/2024/03/03/%E5%9C%A8vercel%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2024/03/03/%E5%9C%A8vercel%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E6%A1%86%E6%9E%B6%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="在vercel上部署hexo框架的博客"><a href="#在vercel上部署hexo框架的博客" class="headerlink" title="在vercel上部署hexo框架的博客"></a>在vercel上部署hexo框架的博客</h1><h2 id="本地部署"><a href="#本地部署" class="headerlink" title="本地部署"></a>本地部署</h2><h3 id="安装Git、Node-js"><a href="#安装Git、Node-js" class="headerlink" title="安装Git、Node.js"></a>安装Git、Node.js</h3><p>Git的安装有多种方式，本文不展开讲。我使用的是<a href="https://desktop.github.com/">GitHub Desktop</a>，在windows和mac上均可下载使用。Node.js可以去<a href="https://nodejs.cn/download/">官网</a>下载相应安装包</p><h3 id="使用npm安装hexo"><a href="#使用npm安装hexo" class="headerlink" title="使用npm安装hexo"></a>使用npm安装hexo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="创建网站"><a href="#创建网站" class="headerlink" title="创建网站"></a>创建网站</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init [folder]</span><br></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo serve</span><br></pre></td></tr></table></figure><p>也可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>启动后默认地址为<a href="http://localhost:4000/">http://localhost:4000/</a></p><h2 id="vercel部署"><a href="#vercel部署" class="headerlink" title="vercel部署"></a>vercel部署</h2><p>首先将存有博客代码的github仓库导入<a href="https://vercel.com/">vercel</a>，在项目的setting中设置指令（如下图）</p><p><img src="https://s2.loli.net/2024/03/03/yFnlUOHpDwQYWER.png" class="lazyload placeholder" data-srcset="https://s2.loli.net/2024/03/03/yFnlUOHpDwQYWER.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="vercel部署hexo指令"></p><p>编辑完成并save后create新的deployment即可，此时可以从vercel给的临时链接访问博客</p><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><p>由于vercel提供的域名需要科学上网访问，平时使用起来不方便，因此我们需要给我们的博客一个域名和DNS解析服务。我选择了阿里云平台购买了域名。购买前需要先实名认证。</p><p>购买成功后，在vercel中setting-&gt;domains下添加购买的域名，并根据主机记录、记录类型和记录值在阿里云平台添加新的解析。</p><h2 id="关于图库"><a href="#关于图库" class="headerlink" title="关于图库"></a>关于图库</h2><p>刚开始我使用github存储图片，但国内访问速度感人，因此使用了<a href="https://sm.ms/">SM.MS</a>作为图床。为了更方便地管理图库，我下载了<a href="https://picgo.github.io/PicGo-Doc/zh/">PicGo</a>来上传图片。只需要在PicGo中添加token即可配置完成。</p><p>SM.MS的token在user-&gt;dashboard-&gt;API token中可以查看</p><h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><h3 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="发表草稿"><a href="#发表草稿" class="headerlink" title="发表草稿"></a>发表草稿</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="更多指令"><a href="#更多指令" class="headerlink" title="更多指令"></a><a href="https://hexo.io/zh-cn/docs/commands">更多指令</a></h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> vercel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
